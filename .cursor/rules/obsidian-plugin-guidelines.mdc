---
description: Obsidian plugin guidelines and compliance requirements
globs: plugin/**/*.ts
alwaysApply: false
---

# Obsidian Plugin Guidelines

This plugin is **desktop-only** (`isDesktopOnly: true` in manifest.json). These guidelines ensure compliance with Obsidian's plugin submission requirements.

Reference: https://docs.obsidian.md/Plugins/Releasing/Plugin+guidelines

## Desktop-Only Considerations

Since we're desktop-only, we CAN use:
- Node.js APIs (`node:fs`, `node:crypto`, `node:os`, `node:path`)
- `child_process` for system commands
- Regex lookbehinds (not supported on iOS < 16.4)

## DOM and UI Guidelines

### Use Obsidian Helper Functions
Build DOM elements programmatically instead of using `innerHTML` for complex structures:

```typescript
// ✅ Good - Use createEl/createDiv/createSpan
const container = parentEl.createDiv({ cls: 'my-class' });
const title = container.createEl('h3', { text: 'Title' });
const button = container.createEl('button', { text: 'Click me' });

// ✅ Good - Use textContent for simple text
button.textContent = '×';
button.setText('Send'); // Obsidian helper

// ✅ Good - Use setIcon for icons
setIcon(deleteBtn, 'trash-2');

// ✅ Good - Clear content with empty()
element.empty(); // NOT element.innerHTML = ''

// ⚠️ Acceptable - innerHTML for decorated content (MUST escape first)
contentEl.innerHTML = this.decorator.decorateText(text); // decorateText escapes HTML

// ❌ NEVER - innerHTML with unescaped user content
contentEl.innerHTML = `<div>${userInput}</div>`; // XSS risk!

// ❌ Avoid - innerHTML for clearing (use .empty() instead)
element.innerHTML = '';
```

**Security**: Never use `innerHTML`, `outerHTML`, or `insertAdjacentHTML` with unescaped user content. If innerHTML is necessary (e.g., rich text editing), always escape content first:

```typescript
// Always escape before innerHTML
function escapeHtml(text: string): string {
    return text
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#039;');
}
```

### Settings UI
- Use Sentence case in all UI text (not Title Case)
- Section headings should NOT contain "Settings" in the text
- General settings go at the top without a heading

```typescript
// ❌ Bad
containerEl.createEl('h3', { text: 'Plugin Settings' });
containerEl.createEl('h3', { text: 'Daemon Settings' });

// ✅ Good
containerEl.createEl('h3', { text: 'Plugin' });
containerEl.createEl('h3', { text: 'Daemon' });
```

### CSS Variables
Use Obsidian's CSS variables for consistent theming:

```css
/* ✅ Good */
background: var(--background-primary);
color: var(--text-normal);
border-color: var(--background-modifier-border);

/* ❌ Avoid hardcoded colors */
background: #ffffff;
```

## File System Guidelines

### Use normalizePath()
Always normalize paths when constructing file paths:

```typescript
import { normalizePath } from 'obsidian';

// ✅ Good
const filePath = normalizePath(`${this.dir}/${filename}.md`);

// ❌ Bad - May have issues with slashes
const filePath = `${this.dir}/${filename}.md`;
```

### Use Proper File Lookup APIs
For specific file lookups, use direct methods instead of iterating:

```typescript
// ✅ Good - Direct lookup
const folder = this.app.vault.getFolderByPath(folderPath);
const file = this.app.vault.getFileByPath(filePath);
const abstractFile = this.app.vault.getAbstractFileByPath(path);

// ⚠️ Acceptable - When searching/filtering multiple files
const files = this.app.vault.getMarkdownFiles().filter(f => f.path.startsWith(prefix));

// ❌ Avoid - Iterating to find a single known file
const file = this.app.vault.getMarkdownFiles().find(f => f.path === knownPath);
```

### Editing Files
Use the appropriate API based on context:

```typescript
// For active/open notes - use Editor
const editor = this.app.workspace.activeEditor?.editor;
editor?.replaceRange(newText, from, to);

// For non-active notes - use Vault.process (atomic read-modify-write)
await this.app.vault.process(file, (content) => {
  return content.replace(oldText, newText);
});

// ❌ Avoid vault.modify - not atomic, can cause race conditions
// const content = await vault.read(file);
// const modified = content.replace(...);
// await vault.modify(file, modified); // BAD: another process may have changed file

// For .spark/ internal files - adapter is fine
await this.app.vault.adapter.write(path, content);
```

### Frontmatter
Use FileManager for vault notes:

```typescript
// ✅ Good - For vault notes
await this.app.fileManager.processFrontMatter(file, (fm) => {
  fm.status = 'done';
});

// ⚠️ Acceptable - For .spark/ internal files parsed manually
const match = content.match(/^---\n([\s\S]*?)\n---/);
```

## Resource Cleanup

Always use Obsidian's cleanup helpers:

```typescript
// ✅ Good - Auto-cleanup on unload
this.registerEvent(this.app.vault.on('modify', callback));
this.addCommand({ id: 'my-command', name: 'My Command', callback });
this.registerDomEvent(document, 'click', handler);
this.registerInterval(window.setInterval(fn, 1000));

// ❌ Bad - Manual cleanup required
this.app.vault.on('modify', callback); // Won't auto-cleanup
document.addEventListener('click', handler); // Memory leak
```

## Manifest Requirements

```json
{
  "id": "spark",
  "name": "Spark Assistant",
  "description": "Description ends with a period.",
  "isDesktopOnly": true,
  "minAppVersion": "1.6.0"
}
```

- Description: max 250 chars, ends with period, no emojis
- Use proper capitalization (Obsidian, Markdown, PDF)
- Version follows semver (x.y.z)

## Required Files

- `LICENSE` - MIT or compatible
- `README.md` - Plugin description and usage
- `manifest.json` - Plugin metadata

## Prohibited

- ❌ Obfuscated code
- ❌ Dynamic ads loaded from network
- ❌ Client-side telemetry
- ❌ Auto-update mechanisms
- ❌ Using "Obsidian" in ways that imply official endorsement
