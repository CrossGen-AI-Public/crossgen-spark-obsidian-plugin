---
alwaysApply: true
---

# Debugging Approach

When fixing bugs, follow these principles to avoid overcomplicating solutions.

## Core Principles

### 1. Understand Before Fixing
- **Never write a fix without understanding the root cause**
- Read and trace the existing code execution flow
- A bug that seems like "X is wrong" might actually be "Y happens in the wrong order"
- If you don't understand why something is happening, dig deeper - don't add workarounds

### 2. Analyze Error Messages Carefully
Error messages are hints, not noise:
- `"the given Node has no parent"` → something is removing nodes from the DOM
- `"undefined is not a function"` → check the execution order and initialization
- Stack traces show the path - trace backwards to find where things went wrong

### 3. Keep Fixes Minimal
- **If your fix is >20 lines for a simple bug, you probably don't understand the problem**
- The best fixes are often:
  - Moving one line
  - Changing the order of operations
  - Removing code, not adding it
  - A single condition check

### 4. Resist Premature Solutions
- Don't jump to coding immediately
- First: Read the code, trace execution, understand the flow
- Then: Identify the minimal change needed
- Finally: Implement the fix

### 5. Question Your Assumptions
- "The cursor is in the wrong place" might actually mean "something is moving the cursor"
- "This needs more logic" might actually mean "existing logic runs at the wrong time"
- **Symptoms ≠ Root Cause**

## Anti-Patterns to Avoid

### ❌ Adding Complexity to Handle Edge Cases
```typescript
// BAD: 67 lines of cursor positioning logic
if (target.classList.contains('spark-token') && !wasInputFocused) {
  // Focus input
  // Try to position cursor after mention
  // Fallback to position at end
  // More fallbacks...
}
```

### ✅ Fixing the Root Cause
```typescript
// GOOD: Move focus() before processContent()
this.inputEl.focus();  // Was after, now before
this.mentionHandler.processContent();
```

### ❌ Working Around Symptoms
- Adding try-catch blocks to suppress errors
- Creating elaborate state management to track edge cases
- Writing defensive code to handle "impossible" states

### ✅ Fixing the Actual Problem
- Trace why the error occurs
- Fix the order of operations
- Remove the conditions that create the edge case

## Real Example: Cursor Positioning Bug

**Initial Symptom**: Cursor goes to beginning when clicking mention in unfocused input

**First (Wrong) Approach**:
- 67 lines of cursor positioning logic
- Multiple fallbacks and error handlers
- Still caused errors: `InvalidNodeTypeError: the given Node has no parent`

**Root Cause Analysis**:
1. Traced the execution: focus() → handleFocus() → processContent()
2. Realized processContent() replaces innerHTML
3. This removes the `spaceText` node
4. setStartAfter(spaceText) fails because node is gone

**Actual Fix**: Move `focus()` before `processContent()` (1 line moved)

## Debugging Checklist

Before writing any fix:
- [ ] Can you explain WHY the bug happens?
- [ ] Have you traced the execution flow?
- [ ] Did you analyze error messages for hints?
- [ ] Is there a simpler root cause you're missing?
- [ ] Would your fix be obvious to someone reading it later?

If you can't check all boxes, you don't understand the problem yet.

After implementing the fix:
- [ ] Run `npm run check` to validate there are no errors

## Remember

> "Debugging is twice as hard as writing the code in the first place. Therefore, if you write the code as cleverly as possible, you are, by definition, not smart enough to debug it." - Brian Kernighan

Write simple fixes. If it's complex, you're solving the wrong problem.
