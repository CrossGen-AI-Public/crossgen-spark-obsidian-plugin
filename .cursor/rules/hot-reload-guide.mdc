---
description: hot reload
alwaysApply: false
---

**Note:** This file describes current hot reload implementation using tsx watch.

# Development Hot Reload Guide

## Overview

Spark uses **tsx watch** for development hot reload - a zero-config, industry-standard tool that automatically restarts the daemon when TypeScript files change.

## Quick Start

```bash
cd daemon
npm run dev          # Standard dev mode
npm run dev:debug    # With debug logging
```

That's it! The daemon will automatically restart on any TypeScript file change.

## How It Works

### tsx watch (Built-in Node.js hot reload)

- **Zero configuration** - works out of the box
- Watches all TypeScript files in `src/`
- Runs TypeScript directly (no build step!)
- Instant restart on changes (~1 second)
- Industry standard, battle-tested tool

### Automatic Config Reload

The daemon itself watches `.spark/config.yaml` and reloads config changes automatically:

- **No daemon restart** needed for config changes
- Updates logger settings dynamically
- Restarts file watcher if patterns change
- Works in both development and production

## Coding Best Practices

### For New Features (like AI integration)

**✅ Good - Import directly in SparkDaemon:**
```typescript
// In SparkDaemon.ts
import { ClaudeClient } from './ai/ClaudeClient.js';

private async processCommand(command: ParsedCommand) {
  const client = new ClaudeClient(this.config.ai);
  const result = await client.chat(messages);
  // Hot reload works perfectly!
}
```

**⚠️ Avoid - Deep nesting:**
```typescript
// SparkDaemon → CommandProcessor → AIOrchestrator → ClaudeClient
// Long chains may require manual restart for deep changes
```

### Singleton Pattern

If you need singletons, implement `resetInstance()`:

```typescript
export class MyService {
  private static instance: MyService;

  public static getInstance(): MyService {
    if (!MyService.instance) {
      MyService.instance = new MyService();
    }
    return MyService.instance;
  }

  public static resetInstance(): void {
    MyService.instance = undefined as unknown as MyService;
  }
}
```

Then reset in daemon lifecycle if needed.

### Avoid Module-Level State

**❌ Avoid:**
```typescript
// Module-level cache persists across restarts
const cache = new Map();

export function getData() {
  return cache.get('key');
}
```

**✅ Better:**
```typescript
// Instance-level state resets with new instance
export class DataService {
  private cache = new Map();
  
  getData() {
    return this.cache.get('key');
  }
}
```

## What Gets Reloaded

### Automatic (no restart needed)
- ✅ Config file changes (`.spark/config.yaml`)
- ✅ Logging settings
- ✅ Watch patterns
- ✅ All config values

### Automatic (with restart ~1s)
- ✅ TypeScript source changes
- ✅ New files added
- ✅ Files deleted
- ✅ Import structure changes

### May need manual restart
- ⚠️ Complex singleton patterns with cached state
- ⚠️ Deep dependency changes (rare)

**If something doesn't reload:** Press `Ctrl+C` and run `npm run dev` again (~1 second)

## NPM Scripts

```bash
# Development
npm run dev          # Start with tsx watch
npm run dev:debug    # With debug logging

# Testing
npm run test         # Run once
npm run test:watch   # Continuous testing

# Production
npm run build        # Build for production
spark start /vault   # Run production build
```

## Why tsx watch?

We simplified from a custom 450-line `HotReloadManager` to using `tsx watch` because:

1. ✅ **Zero maintenance** - industry standard tool
2. ✅ **Works with TypeScript directly** - no build step
3. ✅ **Faster iteration** - instant reload
4. ✅ **Simpler** - 0 lines of custom code
5. ✅ **More reliable** - battle-tested by thousands of projects

## Config Auto-Reload

The daemon watches config files independently of tsx:

```typescript
// In SparkDaemon.ts - automatically watches config
private startConfigWatcher(): void {
  const configPath = join(this.vaultPath, '.spark', 'config.yaml');
  
  this.configWatcher = chokidar.watch(configPath, {
    persistent: true,
    ignoreInitial: true,
    awaitWriteFinish: { stabilityThreshold: 100, pollInterval: 50 },
  });
  
  this.configWatcher.on('change', () => {
    void this.reloadConfig(); // No restart needed!
  });
}
```

This works in **both development and production** - users can change config without restarting their daemon.

## Troubleshooting

### Changes not reloading?
1. Check if file is in `src/` (tsx watches all files there)
2. Check terminal for error messages
3. Try manual restart: `Ctrl+C` then `npm run dev`

### "Cannot find module" errors?
- You may need to restart tsx for new files
- Press `Ctrl+C` and run `npm run dev` again

### Performance issues?
- tsx is very fast (~1s restart)
- If slow, check for very large files or circular imports
